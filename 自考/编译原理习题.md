
## 习题1
- 名词解释
  - 翻译程序：能把某种语言逻辑等价地转换成另一种语言的程序。(翻译分编译和解释)
  - 编译程序：能将高级语言程序翻译为对应的低级语言程序的翻译程序 （ 低级语言指汇编语言或机器语言 ）
  - 解释程序：对高级语言边翻译为机器语言边执行，不保存翻译结果。
  - 源程序：高级语言程序
  - 目标程序：机器语言程序或汇编语言程序
  - 遍
  - 前端：编译程序的前半部分，包括词法分析、语法分析、语义分析、中间代码生成，部分代码优化工作。 与目标机无关的部分。
  - 后端：编译程序的后半部分，包括代码优化、目标代码生成

- 高级语言程序有哪两种执行方式?阐述其主要异同点。描述编译方式执行程序的过程。
  - 方式：解释和编译
  - 异同
    - 编译程序是源语言的转换系统，解释程序是源语言的执行系统。
    - 编译的翻译和执行是两个阶段，产生的目标程序可以反复执行。解释的的翻译和运行是交叉进行的，每次都需要翻译。
    - 编译执行速度快。因为编译阶段已经分析过。但是解释方式排查问题更方便。
    - 解释程序比编译程序更加通用
  - 编译执行的过程

- 在你所使用的C语言编译器中，观察程序1.1经过预处理、编译、汇编、链接四个过程生成的中间结果。
  - 文本替换，.c文件变为.i文件
  - 编译为汇编语言程序
  - 汇编翻译为二进制机器语言代码
  - 链接程序转换为最终可运行的程序（包含了库文件的链接）

- 编译程序有哪些主要构成成分? 各自的主要功能是什么?
  - 词法分析：将源程序分解成一个个单词
  - 语法分析：将单词转换成语法单位，检查语法错误
  - 语义分析：建立符号表，对语法单位逻辑含义静态语义检查
  - 中间代码生成：生成为了便于优化而设计的便于转换指令的代码
  - 代码优化：对中间代码等价变换优化
  - 目标代码生成：翻译为目标机的指令
  - 其中 中间代码生成、代码优化 不是必须的，可以直接由语义分析后生成目标代码

- 编译程序的构造需要掌握哪些原理和技术?编译程序构造工具的作用是什么?
  - 源语言：是编译程序处理的对象。
  - 目标语言与目标机：编译程序处理的结果和运行环境。
  - 编译方法和工具：生成编译程序的关键。
  - 构造工具：编译程序构造工具是一种软件工具，用于帮助编译程序的构造，如lex、yacc、bison等
  

- 复习C语言，其字母表中有哪些符号?有哪些关键字、运算符和界符?标识符、整数 和实数的构成规则是怎样的?各种语句和表达式的结构是怎样的?
  - 字母表：大小写字母、数字、下划线
  - 关键字：int、float、if、else、while、for、return
  - 运算符：+、-、*、/、%、=、==、!=、>、<、>=、<=、&&、||、!、&、|、^、~、<<、>>
  - 界符：{}、()、[]、;、,、.
  - 标识符：字母开头，字母数字下划线组成
  - 整数：十进制、八进制、十六进制
  - 语句：if、while、for、return、break、continue
  - 表达式：赋值表达式、算术表达式、关系表达式、逻辑表达式

- 编译技术可应用在哪些领域?
  - 各种软件工具开发、程序的翻译、新型体系结构的设计

- 你能解释在Java 编译器中，输入某个符号后会提示一些單词、某些單词變为不同的 颜色是如何实现的吗?你能解释在Code Blocks 中在输入{后，会自动添加},输入 do 会自 动添加 while()  是为什么吗?



## 习题2

- 有穷自动机识别的语言是正规语言。 
  - true                  
- 若r1 和r2是 E 上的正则表达式，则 r1|r2 也是。  
  - true
- 设 M 是 一个NFA,  并且L(M)={x,y,z},  则 M 的状态数至少为4个。 
  - false  
- 令 Z={a,b}, 则所有以b开头的字构成的正规集的正则表达式为b*(a|b)* 。 
  - false  b+(a|b)*
- 对任何一个 NFA M,都存在一个 DFA M',使得L(M')=L(M)。 
  - true 一个NFA至少有一个DFA对应

- 从供选择的答案中，选出最确切的解答。
  有穷自动机可用五元组`(Q,Vr,δ,q₀,Q₁)` 来描述，设一个有穷自动机M 定义如下：`Vr= {0,1}, Q={q₀,q₁,q₂}, Q₁={q₂}` 。δ 的定义为： `δ(q₀,0)=q₁ , δ(q₁,0)=q₂, δ(q₂,1)=q₂, δ(q₂,0)=q₂`
  - M 是一个___④____ 有穷状态自动机。
    - ① 歧义的 ②非歧义的  ③确定的  ④非确定的
  - 它所对应的状态转换图为 ②
  - 它所能接受的语言可以用正则表达式表示为 ②
    - `①(0|1)*  ②00(0|1)*   ③(0|1)* 00   ④0(0|1)*0`
  - 其含义为  ④
    - ①由0和1所组成的符号串的集合
    - ②以0为头符号和尾符号，由0和1所组成的符号串的集合
    - ③以两个0结束的，由0和1所组成的符号串的集合
    - ④以两个0开始的，由0和1所组成的符号串的集合       

- 一个长度为n 的字符串，前缀和后缀分别有多少个?如果字符串为 abcd,分别是哪些?
  - 前缀：n+1个，后缀：n+1个  
  - 前缀：ε, a, ab, abc, abcd
  - 后缀：ε, d, cd, bcd, abcd
- 试写出以下各描述中所表示的正则表达式。
  - 以01结尾的二进制数串。
    - `(0|1)*(0|1)`
  - 不以0开头，能被5整除的十进制整数。
    - `(1|2|3|4|5|6|7|8|9)(0|1|2|3|4|5|6|7|8|9)*(0|5)`
  - 包含子串011的由0和1组成的符号串的全体
    - `(0|1)*011(0|1)*`
  - 不包含子串011的由0和1组成的符号串的全体
    
  - 按字典顺序递增排列的所有小写字母串
    - `a*b*c*d*e*f*g*h*i*j*k*l*m*n*o*p*q*r*s*t*u*v*w*x*y*z*`
  - E={0,1}上的含奇数个1的所有串。
    - `0*1 (0* 1 0* 1)*`
  - 包含偶数个0和1的二进制串。
    - `(00 | 11 | 1 (00)* 1 | 0 (11)* 0)*`
  - 具有偶数个0和奇数个1的由0和1组成的符号串的全体
    - `(1(00)* | (00)*1)*`
  - 由 / * 和 * / 括起来的注释的串，且串中没有不在双引号中的 * /
    - `(/\*) L* ("L*\*/L*")* L* (\*/)`
  - 有些语言是大小写敏感的，因此这些语义中的关键字只有一种写法，描述它的正 则表达式比较简单，但SQL 语言是大小写不敏感的，如 select 和 SeLect 、SELECt 等都是一 样的，试描述 SQL 中的关键字 select 的大小写不敏感的正则表达式。
    - `(s|S)(e|E)(l|L)(e|E)(c|C)(t|T)`

- 试描述下列正则表达式所描述的语言。
  - `0(0|1)*0`
    - 以0开头，以0结尾，中间为0和1的串
  - `((ε|0)1*)*`
    - 所有0和1组成的串
  - `(0|1)*0(0|1)(0|1)`
    - 长度至少为3 且 倒数第三位为0 的0和1字符串
  - `0*10*10*10*`
    - 包含3个1，前后和中间有若干个0
  - `(00|11)*((01|10)(00|11)*(01|10)(00|11)*)*`
    - 任何 00 或 11 前必有 01或10 的所有串
- 假定有一台自动售货机，接受1元和5角的硬币，出售每瓶1元5角的饮料，顾客 每次向机器中投放大于1元5角的硬币，就可得到一瓶饮料(注意，每次只给一瓶饮料，且不 找钱),构造该售货机的有穷自动机(可以是NFA  或 DFA)。



## 习题3
- 语法分析器的功能是什么?其输入输出各是什么?
  - 进行语法分析，检查语法和错误处理
  - 输入token值，输出语法树
- 自上而下语法分析和自下而上语法分析的主要差别是什么?

- 自上而下语法分析面临的两个主要问题是什么?如何解决?
  - 回溯导致分析器不稳定：提取公共左因子改造文法。
  - 左递归导致分析过程无限循环：如果包含间接左递归，则先带入变为直接左递归，再使用左递归消除公式。
- 解释下列术语：
  - 上下文无关文法：
  - 推导：从文法开始符号出发，将所有非终结符用产生式右部替换展开，直到全部为终结符。
  - 归约：推导的逆过程。
  - 最左推导：推导过程中，每一步都是替换最左边的非终结符。
  - 二义文法：一个文法存在某个句型有两个或两个以上的不同的推导树
  - 语法树：用一棵树来表示一个句型的推导过程。


  - 句型、句子、语言、文法等价、
  - 规范归约、句柄、短语、最左素短语、活前缀、项目

- 从供选择的答案中，选出应填入的正确答案。
    已知文法 G[S] 的产生式如下：
    ```
    S→(L)|a
    L→L,S|S
    ```
  - 属于L(G[S]) 的句子是 ___①____,
    - ` ①a        ②a,a        ③(L)    ④(L,a) `
  - (a,a) 是 L(G[S]) 的句子，这个句子的最左推导是 ____③___ 最右推导是 ___①____
    - `①S→(L)→(L,S)→(L,a)→(S,a)→(a,a)`
    - `②S→(L)→(L,S)→(S,S)→(S,a)→(a,a)`
    - `③S→(L)→(L,S)→(S,S)→(a,S)→(a,a)`
  - (a,a) 语法树是 ___②____

- 已知某算术表达式的文法G 为，给出i+i+i 和 i+i*i 的最左推导、最右推导和语法树。
  ```
  (1)<AEXPR>→<AEXPR>+<TERM>|<TERM>
  (2)<TERM>→<TERM>*<FACTOR>|<FACTOR>
  (3)<FACTOR>→i|(<AEXPR>)
  ```
  用E表示<表达式>，T表示<项>，F表示<因子>，上述文法可以写为
  ```
  (1)E→E+T|T
  (2)T→T*F|F
  (3)F→i|(E)
  ```
  - i+i+i 最左推导 `E→E+T→E+T+T→F+T+T→i+T+T→i+F+T→i+i+T→i+i+F→i+i+i`
  - i+i+i 最右推导 `E→E+T→E+F→E+i→E+T+i→E+F+i→E+i+i→T+i+i→F+i+i→i+i+i`
  - i+i*i 最左推导 `E→E+T→T+T→F+T→i+T→i+T*F→i+F*F→i+i*F→i+i*i`
  - i+i*i 最右推导 `E→E+T→E+T*F→E+T*i→E+F*i→E+i*i→T+i*i→F+i*i→i+i*i`
  - 语法树略
- 
  



## 习题5
- 解释术语
  - 属性：文法符号相关信息，如类型、值等。（属性计算过程就是语义处理过程）
  - 属性文法：在上下文无关文法基础上，对文法符号定义属性，定义属性计算规则。
  - 继承属性：属性值由其父节点的或兄结点的属性决定
  - 综合属性：属性值由其子节点的属性决定
  - 语义子程序：
  - 语法制导的翻译：语法结构的语义处理方法。
  - 翻译模式：用花括号将语义动作放在产生式中间，表示语义动作执行时机。 E' -> +T {print('+')} E'
- 为什么要生成中间代码? 常见的中间代码有哪几种形式?
  - 好处
    - 便于与机器无关的代码优化
    - 使编译程序改变目标机更容易
    - 是编译程序的结构在逻辑上更为简单、明确。
  - 形式：逆波兰式、三地址码、有向无环图、抽象语法树
- 分别为如下文法配上语义子程序。
  - 文法 G₁ 由开始符S 产生一个二进制数，综合属性 val 给出该数的十进制值。试设计求 S.val  的属性文法，其中，已知B 的综合属性，它是由B 产生的二进制的结果 值。对该属性文法如输入二进制101.101,则输出S.val=5.625。
    ```
    S→L.L|L
    L→LB|B
    B→0|1'
    ```
    
    ```
    S -> L1.L2 {S.val = L1.val + L2.val}
    S -> L { S.val = L.val }
    L -> L1B 
    ```
    
  - 有文法G₂。为此文法配上语义动作子程序(或者说为此文法写出一个语法制导的定义),使其输出 配对括号的个数，如对于句子(a,(a,a)), 输出是2。
    ```
    S→(L)|a
    L→L,S|S
    ```
    
  - 文法G₃ 的产生式如下。试写出各个产生式的语法制导的翻译规则，打印该程序一共声明了多少个id。
    ```
    P→D
    D→D;D|id:T      l      proc      id;D;S
    ```
- 文法G 及相应的语法制导的翻译规则为, 若输入串为 bcccaadadadb 时，其输出是什么? 
  ```
  P→bQb   {print("1")}
  Q→cR {print("2")
  Q→a   {print("3")
  R→Qad  {print("4")}
  ```


- 请把逆波兰式 `ab+cde3-/+8*+` 复原成中缀表达式。
  - `(a+b)+(c+d/(e-3))*8`
- 给出下面表达式的逆波兰式
  - a*(-b+c)  
    - ab@c+*
  - !AⅡ!(CⅡ!D)
    - A not C D not or not or
  - a+b*(c+d/e)
    - abcde/+*+
  - (A&&B)||(!C||D)
    - A B and C not D or or
  - -a+b*(-c+d)
    - a@bc@d+*+
  - (A||B) && (C || !D && E)
    - A B or CD not E and or and
  
- 分别给出下述表达式的三元式、四元式序列和DAG
  - -(a+b)*(c+d)-(a+b+c)
    | 三元式 | 四元式 |
    | --- | --- |
    | (+,a,b) | (+,a,b,T1) |
    | (@,1,) | (@,T1,,T2) |
    | (+,c,d) | (+,c,d,T3) |
    | (*,2,3) | (*,T2,T3,T4) |
    | (+,a,b) | (+,a,b,T5) |
    | (+,5,c) | (+,T5,c,T6) |
    | (-,4,6) | (-,T4,T6,T7) |


  - AⅡ(B&&!(C||D))
    
- 根据while 语句的目标结构写出while 语句的属性文法。


- 利用表5.4定义的语义规则，给出表达式(3+4)*(5+6)的带注释的语法分析树

- C 语言中没有布尔类型，试说明C 语言编译器可能使用什么方式将一个 if语句翻 译为四元式

- 语句翻译为四元式 （语句看书）

- 用自己熟悉的语言编写程序，其功能是将布尔表达式翻译为四元式代码
 

- 用自己熟悉的语言编写程序，其功能是将简单赋值语句翻译为四元式代码。

- 在第3章写的各种控制语句的递归下降分析程序的基础上，实现其递归下降的语 法制导翻译程序，翻译为四元式代码。

- 理解函数声明、定义和调用，用自己熟悉的语言编写程序，实现函数的四元式代码 生成 。

-  xxx
  ```
  if (w < 1) {
    a = b*c;
  } else {
    a = 33;
  }
  ```
  - (1) (j<,w,1,3)
  - (2) (j,,,6)
  - (3) (*,b,c,T1)
  - (4) (=,a,,T1)
  - (5) (j,,7)
  - (6) (=,a,,33)
  - (7) 

## 习题7
- 在对编译程序产生的中间代码进行优化时，就实施优化的范围来说，分 _____ 优化和 _____ 优化。循环优化属于_____优化，它对于提高目标代码的运行速度是非常有效的。循环优化主要采用的三项优化措施是_____。
- 基本块：程序中一个顺序执行的语句序列，只有一个入口和一个出口。入口是第一个语句，出口是最后一个语句
- 流图，DAG, 循环，回边，必经结点，局部优化
- 什么是代码优化?代码优化如何分类?常用的代码优化技术有哪些? 

#### 习题8
- 一个编译程序的目标代码生成阶段主要需要考虑哪些问题?
  - 能产生高效正确的目标代码，并且易于实现、测试和维护。
- 引用信息和活跃信息的作用是什么?如何实现?

- 寄存器描述和地址描述的作用是什么?如何实现?

- 生成下列 Sample 语句的目标代码，假定所有变量均为静态分配，并有三个寄存器
可用。
  1. x=1
  2. x=y
  3. x=x+1
  4. x=a+b*c
  5. x=a/(b+c)-d*(e+f)

- 利用简单代码生成算法，对下列三地址代码生成目标代码。其中，V是基本块出口的活跃变量，设可用寄存器为AX 和 BX
  ```
  (-,A,B,T)
  (+,C,D,S)
  (-,E,F,W)
  (/,W,T,U)
  (*,U,S,V)
  ```
- 假定所有变量都存放在内存中，为下列赋值语句生成目标代码。
  ```
  (1)x=a+b*c
  (2)x=(a/b-c)/d
  (3)x=(a*-b)+(c-(d+e))
  (4)if   x<y   goto   Ll
  x=0
  Goto L2
  L1:z=1
  L2:
  ```
- 将表达式A*(B+C)-D*(B+C) 采用四元式进行表达，并生成相应的80x86 汇编 代码。假设变量 A、B、C、D分别对应栈帧中的内存单元(SP)+14H 、(SP)+16H 、(SP)+
18H 、(SP)+1AH,    每个变量占两字节。可用寄存器为 AX 、CX 、DX,寄存器的初始状态 为空。


- 算法程序题。
  1. 编程实现简单代码生成算法。

  2. 用算法描述寄存器的分配算法，计算活跃信息和引用信息。

  3. 试给出一个算法，直接对DAG 计算引用信息和活跃信息。