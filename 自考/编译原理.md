
### 一、编译概述
- 计算机语言的层次关系：机器语言和汇编语言与机器有关称为低级语言，其它语言与机器无关称为高级语言。
- 高级语言程序运行两种方式：编译、解释。
- 编译程序（编译器）：能将高级语言程序翻译为对应的低级语言程序的翻译程序。
- 编译方式与解释方式对比
  - 编译程序是翻译为目标程序，目标程序可反复执行。 解释程序对源程序逐句翻译并执行，目标代码只执行一次，再执行需要重新解释。
  - 编译方式，源程序和数据在不同时间处理。 解释方式源程序和数据在同一时间处理。
  - 编译方式比解释方式执行快得多，因为分析过了。 解释方式错误诊断更友好易于调试。
  - 编译程序是源程序一个转换系统，解释程序是源程序的一个执行系统。
  - 解释程序更加通用。

- 高级语言编译流程（理解）
  - 预处理。 源代码部分文本替换。(例如`#include x.h`就把`x.h`的内容替换到这里)
  - 编译。核心，将高级语言代码翻译成汇编代码。（也有些语言跳过汇编直接生成可执行二进制）
  - 汇编。将汇编代码翻译成机器代码。
  - 链接。链接程序把目标文件转换为最终可运行的程序。分动态链接和静态链接。

- 编译过程的六个阶段（理解）（例：`area = 5 + length * width + length * width`）
  - 词法分析。将源程序分解成单词。
    - 分解成`id1 = int1 + id2 * id3 + id2 * id3`
  - 语法分析。分析单词，转换成语法单位，检查语法错误。 (参考图1.13)
    - 语法树
      ```
                赋值语句
        /         |            \
      标识符       =            表达式
       |                   /     |       \
      id1               表达式   +          表达式
                      /  |  \             /  |  \
                  表达式  +  表达式       表达式 *  表达式
                    |     /  |  \         |        |
                   常数  表达式 * 表达式   标识符    标识符
                    |     |       |       |        |
                  int1  标识符   标识符    id2      id3
                          |       |
                         id2     id3
      
      ```
  - 语义分析。 建立符号表，对语法单位逻辑含义静态语义检查。(参考表1.2)
  - (中间代码生成)。为了优化而设计的，含义明确便于处理的记号系统。 多采用四元式。
    - 下图 `t1,t2,t3,t4` 表示临时工作变量。
      |序号|四元式| 
      |---|---| 
      |1| ( *, id2, id3, t1)|
      |2| ( +, int1, t1, t2) |
      |3| ( =, id2, id3, t3) |
      |4| ( +, t2, t3, t4) |
      |5| ( =, t4, , id1) |
  - (代码优化)。对中间代码等价变换，产生更高质量的目标代码。(执行了两次`id2 * id3`，第二次可以直接使用第一次的结果)
  - 目标代码生成。根据语法树翻译为目标机的指令。(参考表1.3)

- 编译程序的六个模块（理解）
  - 词法分析器
  - 语法分析器
  - 语义分析器
  - 中间代码生成器
  - 代码优化器
  - 目标代码生成器

- 构造编译程序的五种方法（识记）
  - 直接用机器语言或汇编语言编写(早期这么干的)
  - 用高级语言编写(现在普遍这么干)
  - 自编译
  - 用编译工具自动生成
  - 移植

- 构造编译程序要考虑的三个要素（理解）
  - 源语言：是编译程序处理的对象。
  - 目标语言与目标机：编译程序处理的结果和运行环境。
  - 编译方法和工具：生成编译程序的关键。

- 高级语言的构成成分（识记）：语法、语义、语用。
- 高级语言程序结构（应用）
  - 字符。
  - 单词。(变量)
  - 数据引用。（数据类型）
  - 表达式。基本成分，对数据的运算。
  - 语句。流程控制`if、while、for`等。
  - 函数。
  - 程序。最大语法单位，例`main()`函数。

- 编译程序的发展（识记）：20世纪50年代IBM公司FORTRAN语言
- 编译技术的应用（识记）：各种软件工具开发、程序的翻译、新型体系结构的设计。
- 学习编译原理的目的（理解）
  - 有助于深刻理解和正确使用程序设计语言
  - 有助于加深对计算机系统的理解
  - 设计开发编译程序的软件技术同样可以用于其他软件的设计开发
  - 编译技术的地位越来越重要


### 二、词法分析
- 实现方式：正则表达式和有穷自动机
- 任务
  - 扫描源文件，读取字符流到缓冲区
  - 识别单词，输出单词和种别码
  - 过滤无用成分。如空格、注释、换行等
  - 识别定位错误，调用错误处理程序
- 两种实现方式：手工编写词法分析器、使用词法分析器生成器

- 单词分类：关键字、标识符(变量)、运算符、界符(符号)、常数(这里除了数字，字符串和布尔等也是常数)
- 单词种别码：又称token值，用整数编码表示。
  - 例：`if (r=1)` 参照种别码表分析后输出 `(111,"if")、(201,"(")、(700,"r")、(219,"=")、(400,"1")、(202,")")`

- 状态转换图和单词识别：重点掌握
- 超前搜索技术和双界符的识别


- 词法分析器
  - 接口：源程序 -> 词法分析器 -> {token文件, 错误信息}
  - 工作流程
    - 读一非空字符
    - 首字符分类
    - 识别标识符/关键字
    - 识别数值型常数
    - 处理注释和除号
    - 识别字符常数
    - 识别字符串常数
    - 识别运算符和界符

- 符号串`s`的长度是其符号个数，记作`|s|`，长度为0的空串不包含符号记作`ε`
- 集合
  - 并。 $U \cup V$ 表示。 全部符号串的并集。
  - 连接。 $UV$ 表示。 $U$ 中任意一符号串与 $V$ 中任意一符号串连接构成的符号串集合。 一般来说有顺序区分 $UV \neq VU$ ，但是 $(UV)W = U(VW)$ 。
  - 闭包。 $U^*$ 表示。 $U$ 中任意符号串连接任意次构成的符号串集合。 $U^* = U^0 \cup U^1 \cup U^2 \cup U^3 \cup \cdots$ 
    - n次方幂。 $U^n$ 表示。 $U$ 中任意符号串连接 $n$ 次构成的符号串集合。
    - $U^0 = ε$
    - 正闭包。 $U^+$ 表示。 至少有一个。 $U^+ = UU^* = U^1 \cup U^2 \cup U^3 \cup \cdots$，即去掉 $ε$ 。
    - 例 $\Sigma = \{a,b\}$， 求 $\Sigma^*、\Sigma^+$ 。
      - $\Sigma^*=\{ε,a,b,aa,ab,ba,bb,aaa,\cdots \}$ 
      - $\Sigma^+=\{a,b,aa,ab,ba,bb,aaa,\cdots \}$ 

- 正则表达式
- 有穷自动机：有输入输出的系统，处于有限状态中的一个。 是状态转换图的形式化表示。识别正则表达式的集合。
  - DFA：确定的有穷自动机。一个状态下输入一个符号，只有一个确定的下一个状态。
  - NFA：不确定的有穷自动机。一个状态下输入一个符号，可能有两个或两个以上的后继状态。
- DFA
  - 五元组。 $M=(S,\Sigma,\delta,s_0,F)$
    - $S$ 是有穷状态集合
    - $\Sigma$ 是有穷输入字母表
    - $\delta$ 是状态转换函数。 $\delta:S \times \Sigma \to S$
    - $s_0$ 是初始状态。初态。
    - $F$ 是接受(终结)状态集合。终态集合。

- 词法自动生成工具Lex
  - d

- 错误（识记）
  - 分类
    - 非法字符错误
    - 拼写错误
    - 注视、字符常数、字符串常数不闭合。 例如 `/*` 、 `'a` 、 `"abc`
    - 错误的“与”“或”运算
    - 变量声明重复
  - 恢复：词法分析器遇到错误时不直接停止，而是继续分析，一次性发现更多错误，以便程序员一次性修改。这需要词法分析器对源程序做必要的处理，不更正错误，继续分析。称为错误恢复。
    - 从剩余输入中删除一个或多个字符，跳过最小出错单位
    - 向剩余输入中插入一个遗漏的字符
    - 用一个字符替换另一个字符
    - 交换两个相邻字符

### 三、语法分析
- 核心地位。任务是在正确的词法分析后，根据语言定义的语法规则，分析识别语法成分，并进行语法检查和错误处理。
- 输入：token串。  输出：语法树。
- 语法规则：上下文无关文法。它是用递归的方式描述语法规则。
- 语法分析方法
  - 自上而下分析法。常用。
  - 自下而上分析法
- 文法
  - 定义：描述语言的准确可理解的语法规则

- 语法树（应用）
  - 用一棵树表示一个句型的推导过程。
  - 倒立的树，根节点是开始符号，叶子结点由非终结符、终结符、ε 标记。

- 二义文法（应用）
  - 定义：一个文法存在某个句型有两个或两个以上的不同的推导树。
- 消除二义性

- 自上而下语法分析
  - 面临的问题：回溯导致分析器不稳定；左递归导致分析过程无限循环。
  - LL(1)文法

  - 递归下降分析方法
  - 预测分析方法

### 四、语义分析
- 语义：源程序及其组成部分所表述的含义。（语法无关上下文，语义有关上下文，例如声明`x=1`，然后当作函数使用`x()`，0作为除数，语法正确，语义错误)
- 静态语义和动态语义：静态是编译阶段能检查的，动态是运行时检查的。
- 语义分析的任务：对结构正确的源程序进行上下文有关性质的审查。  建立符号表，静态语义检查，发现语义错误。
- Sample语言的语义描述
  - 程序的语义（识记）：`main()`函数、零到多个声明语句、零到多个函数构成。
  - 函数的语义（识记）：函数分为 函数声明、函数定义、函数调用。（函数声明必须出现在 `main()`函数前面。包含 函数名、返回值类型、参数个数和类型，参数只说明类型不能有变量名）
  - 变量是数据的符号化形式，函数是代码的符号化形式。
- 符号表
  - 符号表：编译过程中，建立一些表格来记录源程序的各种名字和属性等，以便语义检查。
  - 符号表功能：收集符号信息、进行语义合法性检查。
  - 符号表的组织方式（理解）：变量表、常量表、函数表、字符串常量表。
  - 符号表的操作（理解）：插入操作、查找操作。
- 静态语义检查
  - 概述（理解）：编译阶段完成的语义检查，所以是静态。审查语法成分的静态语义是否正确，报告程序的语义错误。检查的内容包括：名字、类型、控制流、一致性。
  - 声明与定义语义检查（应用）
    - 变量未声明就使用，变量重定义。
    - 函数未声明就定义和调用，函数重定义，函数声明与定义不匹配，函数调用与声明不匹配。
    - 数组长度必须正整数
    - ...
  - 表达式语义检查（应用）
    - 函数调用时形参和实参类型、个数不匹配。
    - 有 `void` 返回值的函数不参与表达式运算。
    - 操作符作用于不相容的操作数，必须报错。
    - 数组下标运算错误，下标只能作用于数组，指针地址访问只能作用于指针。
    - 赋值表达式不能作为左值
    - 赋值表达式类型不匹配。
  - 语句语义检查（应用）：`break、continue、return`特殊不能随意出现。




### 五、中间代码生成
- 中间代码生成概述（识记）
  - 属性文法：在上下文无关文法基础上，对文法符号定义属性，定义属性计算规则。
  - 生成中间代码的好处：
    - 便于与机器无关的代码优化
    - 使编译程序改变目标机更容易
    - 是编译程序的结构在逻辑上更为简单、明确。
- 中间代码（理解）
  - 逆波兰式：略
  - 三地址代码：略
  - 有向无环图表示：略
- 属性文法（应用）
  - 属性的计算过程就是语义处理的过程
  - 属性分类：综合属性、继承属性。 综合属性自下而上传递信息，继承属性自上而下传递信息。
  - 属性的计算
  - 属性的计算顺序
  - 语法制导翻译的实现方法

- 声明语句的语义处理（理解）
  - 常量声明语句
  - 变量声明语句
  - 函数声明语句

- 表达式的翻译
- 布尔表达式的翻译
- 控制语句的翻译

- 中间代码生成器的设计
  - 中间代码生成器的接口：token文件 -> 中间代码生成器 -> {符号表,错误信息,四元式表}
  - 四元式序列和四元式表：(运算符，运算对象1，运算对象2，结果)

  `id1 = int1 + id2 * id3 + id2 * id3`

  |序号|四元式|
  |---|---|
  |1| ( *, id2, id3, t1)|
  |2| ( +, int1, t1, t2) |
  |3| ( =, id2, id3, t3) |
  |4| ( +, t2, t3, t4) |
  |5| ( =, t4, , id1) |
  
  



### 六、运行时存储组织
- 程序执行时存储器的划分：代码区、静态数据区、动态数据区
- 活动记录
  - 概念：一个函数一次执行中所需的全部信息所存放的一块连续存储区
  - 包含：局部变量和常数、临时变量、形式参数、返回地址、保护区
- 局部数据布局，整数对齐。

- 名字的绑定：把名字和存储单元联系起来。
- 名字的作用域：程序可能存在不同部分相同名字的声明，一个声明在它起作用的那部分程序称为名字的作用域。

- 函数
  - 函数是一个程序块。
  - 函数声明，声明一个名字表示这个函数名，参数个数及类型，返回值类型。(没有返回值也可) 
  - 函数定义，把函数名和一段代码联系起来。（这段代码称为函数体）
  - 函数调用，执行被调用函数的函数体。
- 函数执行时的活动
  - 函数的活动：函数的一次执行
  - 递归函数：函数没有退出当前活动时又开始了新的活动
  - 活动树

- 参数传递方式
  - 传地址。把实参得地址传递给形参，形参通过地址访问实参。
  - 得结果。
  - 传值。
  - 传名。

- 存储分配策略（理解）
  - 静态存储分配。编译时确定数据所需存储空间，运行时也不改变。
  - 栈式存储分配。函数调用时，在栈的顶部为活动记录分配空间，退出时释放该分配空间。
  - 堆式存储分配。运行时把存储空间组织为堆结构，动态分配和释放存储空间，不因函数的退出而释放。（堆是一片连续的足够大的存储区）

- C语言编译程序运行时存储实例（识记）
  - 内存中，系统程序存放在低地址，用户程序存放在相对低端部分。 代码区、静态数据、动态数据（堆、共享区、栈）由低到高。
  - CPU的3个寄存器：IP、SP、BP。 IP指令指针，SP栈指针，BP基址指针。BP指向栈底，SP指向栈顶。BP和SP之间的栈空间就是函数运行时的栈帧。  栈的执行顺序是后进先出。
  - 程序运行时内存变化：（略）

### 七、代码优化
- 代码优化的地位（识记）
  - d

- 基本块（应用）
  - 概念：程序中一个顺序执行的语句序列，只有一个入口和一个出口。入口是第一个语句，出口是最后一个语句。
  - 流图：略

- 优化
  - 局部优化：优化时只考虑一个基本块内的语句。
  - 全局优化：整个程序范围内进行优化。
  - 目的：变换后盛出更有效等价的目标代码。
  - 等价：不改变程序的运行结果。
  - 有效：运行时间更短，占用存储空间更小。
- 优化方式（理解）
  - 删除公共子表达式
  - 复写传播
  - 删除无用代码
  - 代数恒等变换
- 基本块的DAG表示及优化（应用）
  
- 循环优化（理解）
  - 技术方法
    - 代码外提。把循环中的不变计算放到循坏外，程序结果不变，速度提高。
    - 强度削弱。把程序中执行时间较长的运算替换为执行时间较短的运算。
    - 删除归纳变量。循环中有两个或更多的
  - 必经结点：每条到达n的路径都要经过结点d，则d为n的必经结点。写作 `d dom n`。（每个结点是它本身的必经结点，循环的入口是所有结点的必经结点）
  - 必经结点集：到达4有两条路径`1-2-3-4`和`1-2-4`，则必经结点集写作 `D(4)={1,2,4}`
  - 循环：程序中可能反复执行的代码序列。
  - 循环基本性质
    - 必有唯一的入口结点。
    - 至少有一条路径回到入口结点。
  - 回边：`n -> d`


### 八、目标代码生成
- 概述（识记）
  - 代码生成器的设计目标：能产生高效正确的目标代码，并且易于实现、测试和维护。
  - 目标代码生成过程的细节：
    - 代码生成器的输入。中间代码序列和符号表。
    - 代码生成器的输出。目标程序。
    - 指令的选择。
    - 寄存器的分配。
    - 计算顺序的选择。
    - 存储管理。
- 目标机及指令系统 （识记）
  - 80x86体系结构：Intel开发的一种微处理器体系结构的泛称。
  - 80x86中的寄存器
  - 80x86指令系统：数据传送指令、算术逻辑运算指令、转移指令
- 四元式代码翻译（理解）

- 基本块代码生成
  - 引用信息和活跃信息（理解）
  - 寄存器描述和地址描述（应用）
  - 基本块的代码生成（应用）

- DAG生成目标代码（识记）

- 目标代码生成器的结构（理解）
- 汇编指令的选择（理解）
- 构成完整的汇编语言程序（理解）